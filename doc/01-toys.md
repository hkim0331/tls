# 01. Toys

プログラム、データはアトムとリスト。それ以外はない。

* アトム --- それ以上分解できない最小のオブジェクト。数そのものだったり、
他のオブジェクトの名前になる。

1, 2, a, b,

* リスト --- アトムあるいはリストの集まり。要素を( ) で括ったもの。
要素間の区切りは一個以上のスペース文字。

(), (1), (1 2 3), ((1) (2 3) (((4)))),


## car, cdr , cons

car と cdr はリストを分解し、cons はリストを合成する。


* car の代わりに first
* cdr の代わりに rest を使うのが流行りだ。

しかし、(first (first (rest x)) =>  (caad x) とも書けることを知っておくと良い。


## REPL

ターミナルから racket で REPL が起動する。

プログラム(S式)を入力してエンターで、プログラムを評価した結果が表示される。
REPL (Read, Eval, Print, Loop)

```
% racket
Welcome to Racket v8.8 [cs].
> (first '(1 2 3))
1
> (rest '(1 2 3))
'(2 3)
> (first '((1 2 3)))
'(1 2 3)
> (rest '((1 2 3)))
'()
>
```

(cons sexp list) で sexp を list の先頭に入れたリストを返す。

```
> (cons 0 '(1 2 3))
'(0 1 2 3)
```

## 前置形

Scheme は (a b c) という S 式を REPL に入れると

* 関数名は a
* 引数は b と c

という関数呼び出しと解釈する。

(a b c) は「関数 a が引数 b,c を持って呼び出される」になる。
日常的な 1+2 は、

```
> (+ 1 2)
3
```

となる。1+2 の中置型じゃないと式が読めないってのは心が狭い。
前置きにすることで四則演算と他の関数を同一に扱える。
関数中置きの1+2+3+4+5+6+7+8+9+10 は前置きで

```
> (+ 1 2 3 4 5 6 7 8 9 10)
55
;; 後で apply 教える。リストの先頭に関数名を入れ込んだリストを
;; 関数と思って実行する。
> (apply + (range 1 11))
55
```

## クオート(')

(a b c) を関数呼び出し`ではなく`、連続するデータ a b c と解釈させるには、
'(a b c) とする。

```
> '(+ 1 2)
'(+ 1 2)
```

クオート(')とカッコ(()) はアトムを構成する文字として使えない。
そのほかの文字は`使える`。

$$$ とか love! とか、email@address はアトム。


## null?

リストが '() だったら真を返す。真は #t で表す。偽は #f.

```
> (null? '())
#t
> (null? '(1))
#f
```

## (eq? a b)

アトム二つを引数に取り、同値であれば #t、そうでない時 #f.

```
> (eq? 1 1)
#t
> (eq? 'a 'a)
#t
> (eq? 'a 'b)
#f
```

アトム以外の引数で呼ぶと予期するような戻り値が来ないので注意。

```
> (eq? 1 '(1))
#f
> (eq? '(1) '(1))
#f
```



